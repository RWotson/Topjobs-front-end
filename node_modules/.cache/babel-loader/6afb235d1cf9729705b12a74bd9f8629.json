{"ast":null,"code":"import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes - used to control \"return focus\"\n * @param innerTabbables - used to control \"autofocus\"\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\n\nexport var newFocus = function (innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {\n  var cnt = innerNodes.length;\n  var firstFocus = innerNodes[0];\n  var lastFocus = innerNodes[cnt - 1];\n  var isOnGuard = isGuard(activeElement); // focus is inside\n\n  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n    return undefined;\n  }\n\n  var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1; // no active focus (or focus is on the body)\n\n  if (activeIndex === -1) {\n    // known fallback\n    if (lastNodeInside !== -1) {\n      return lastNodeInside;\n    }\n\n    return NEW_FOCUS;\n  } // new focus, nothing to calculate\n\n\n  if (lastNodeInside === -1) {\n    return NEW_FOCUS;\n  }\n\n  var indexDiff = activeIndex - lastIndex;\n  var firstNodeIndex = outerNodes.indexOf(firstFocus);\n  var lastNodeIndex = outerNodes.indexOf(lastFocus);\n  var correctedNodes = correctNodes(outerNodes);\n  var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex); // old focus\n\n  if (!indexDiff && lastNodeInside >= 0) {\n    return lastNodeInside;\n  } // no tabbable elements, autofocus is not possible\n\n\n  if (innerTabbables.length === 0) {\n    // an edge case with no tabbable elements\n    // return the last focusable one\n    // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to\n    return lastNodeInside;\n  }\n\n  var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);\n  var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]); // first element\n\n  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnLastNode;\n  } // last element\n\n\n  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnFirstNode;\n  } // jump out, but not on the guard\n\n\n  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n    return lastNodeInside;\n  } // focus above lock\n\n\n  if (activeIndex <= firstNodeIndex) {\n    return returnLastNode;\n  } // focus below lock\n\n\n  if (activeIndex > lastNodeIndex) {\n    return returnFirstNode;\n  } // index is inside tab order, but outside Lock\n\n\n  if (indexDiff) {\n    if (Math.abs(indexDiff) > 1) {\n      return lastNodeInside;\n    }\n\n    return (cnt + lastNodeInside + indexDiff) % cnt;\n  } // do nothing\n\n\n  return undefined;\n};","map":{"version":3,"names":["correctNodes","pickFocusable","isGuard","NEW_FOCUS","newFocus","innerNodes","innerTabbables","outerNodes","activeElement","lastNode","cnt","length","firstFocus","lastFocus","isOnGuard","indexOf","undefined","activeIndex","lastIndex","lastNodeInside","indexDiff","firstNodeIndex","lastNodeIndex","correctedNodes","correctedIndex","correctedIndexDiff","returnFirstNode","returnLastNode","Math","abs"],"sources":["C:/Users/senethg/Desktop/Mobile App/Test/test server/Gymekalk/client/node_modules/focus-lock/dist/es2015/solver.js"],"sourcesContent":["import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes - used to control \"return focus\"\n * @param innerTabbables - used to control \"autofocus\"\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\nexport var newFocus = function (innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {\n    var cnt = innerNodes.length;\n    var firstFocus = innerNodes[0];\n    var lastFocus = innerNodes[cnt - 1];\n    var isOnGuard = isGuard(activeElement);\n    // focus is inside\n    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n        return undefined;\n    }\n    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n    // no active focus (or focus is on the body)\n    if (activeIndex === -1) {\n        // known fallback\n        if (lastNodeInside !== -1) {\n            return lastNodeInside;\n        }\n        return NEW_FOCUS;\n    }\n    // new focus, nothing to calculate\n    if (lastNodeInside === -1) {\n        return NEW_FOCUS;\n    }\n    var indexDiff = activeIndex - lastIndex;\n    var firstNodeIndex = outerNodes.indexOf(firstFocus);\n    var lastNodeIndex = outerNodes.indexOf(lastFocus);\n    var correctedNodes = correctNodes(outerNodes);\n    var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n    var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);\n    // old focus\n    if (!indexDiff && lastNodeInside >= 0) {\n        return lastNodeInside;\n    }\n    // no tabbable elements, autofocus is not possible\n    if (innerTabbables.length === 0) {\n        // an edge case with no tabbable elements\n        // return the last focusable one\n        // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to\n        return lastNodeInside;\n    }\n    var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);\n    var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);\n    // first element\n    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnLastNode;\n    }\n    // last element\n    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnFirstNode;\n    }\n    // jump out, but not on the guard\n    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n        return lastNodeInside;\n    }\n    // focus above lock\n    if (activeIndex <= firstNodeIndex) {\n        return returnLastNode;\n    }\n    // focus below lock\n    if (activeIndex > lastNodeIndex) {\n        return returnFirstNode;\n    }\n    // index is inside tab order, but outside Lock\n    if (indexDiff) {\n        if (Math.abs(indexDiff) > 1) {\n            return lastNodeInside;\n        }\n        return (cnt + lastNodeInside + indexDiff) % cnt;\n    }\n    // do nothing\n    return undefined;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}