{"ast":null,"code":"import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue) {\n    super(unresolvedKeyframes, onComplete, name, motionValue, motionValue === null || motionValue === void 0 ? void 0 : motionValue.owner, true);\n  }\n\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      element,\n      name\n    } = this;\n    if (!element.current) return;\n    super.readKeyframes();\n    /**\n     * If any keyframe is a CSS variable, we need to find its value by sampling the element\n     */\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      const keyframe = unresolvedKeyframes[i];\n\n      if (typeof keyframe === \"string\" && isCSSVariableToken(keyframe)) {\n        const resolved = getVariableValue(keyframe, element.current);\n\n        if (resolved !== undefined) {\n          unresolvedKeyframes[i] = resolved;\n        }\n      }\n    }\n    /**\n     * Check to see if unit type has changed. If so schedule jobs that will\n     * temporarily set styles to the destination keyframes.\n     * Skip if we have more than two keyframes or this isn't a positional value.\n     * TODO: We can throw if there are multiple keyframes and the value type changes.\n     */\n\n\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return this.resolveNoneKeyframes();\n    }\n\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    /**\n     * Either we don't recognise these value types or we can animate between them.\n     */\n\n    if (originType === targetType) return;\n    /**\n     * If both values are numbers or pixels, we can animate between them by\n     * converting them to numbers.\n     */\n\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else {\n      /**\n       * Else, the only way to resolve this is by measuring the element.\n       */\n      this.needsMeasurement = true;\n    }\n  }\n\n  resolveNoneKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name\n    } = this;\n    const noneKeyframeIndexes = [];\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n  }\n\n  measureInitialState() {\n    const {\n      element,\n      unresolvedKeyframes,\n      name\n    } = this;\n    if (!element.current) return;\n\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin; // Set final key frame to measure after next render\n\n    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n    if (measureKeyframe !== undefined) {\n      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n    }\n  }\n\n  measureEndState() {\n    var _a;\n\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element.current) return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n\n    if (finalKeyframe !== null) {\n      this.finalKeyframe = finalKeyframe;\n    } // If we removed transform values, reapply them before the next render\n\n\n    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n      this.removedTransforms.forEach(_ref => {\n        let [unsetTransformName, unsetTransformValue] = _ref;\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n\n    this.resolveNoneKeyframes();\n  }\n\n}\n\nexport { DOMKeyframesResolver };","map":{"version":3,"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","owner","readKeyframes","element","current","i","length","keyframe","resolved","undefined","has","resolveNoneKeyframes","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","finalKeyframe","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"sources":["C:/Users/senethg/Desktop/Mobile App/Test/test server/Gymekalk/client/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, motionValue === null || motionValue === void 0 ? void 0 : motionValue.owner, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            const keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\" && isCSSVariableToken(keyframe)) {\n                const resolved = getVariableValue(keyframe, element.current);\n                if (resolved !== undefined) {\n                    unresolvedKeyframes[i] = resolved;\n                }\n            }\n        }\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return this.resolveNoneKeyframes();\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}